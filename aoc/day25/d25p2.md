# Day 25: Reactor Core Synchronization - Part 2

The activation signals have reached all reactor cores successfully! But as the reactors power up, something unexpected happens...

"Wait, look at this!" The engineer elf points to a holographic display showing thousands of parallel timelines branching and converging. "The quantum entanglement is creating **superposition states**! Each signal isn't taking just ONE path - it's taking ALL POSSIBLE paths simultaneously!"

She pulls up the quantum mechanics manual. "According to this, when signals travel through the quantum-entangled network, they exist in superposition across all valid paths. The final reactor state depends on the **total number of distinct path combinations** that reach all reactors."

## Part 2: Quantum Path Enumeration

In the quantum realm, signals don't just find the shortest path - they explore ALL possible paths through the network. However, there are rules:

1. **No backtracking**: A signal cannot visit the same chamber twice on a single path (this would cause quantum decoherence)
2. **All reactors must be reached**: You need to count path combinations where signals reach ALL reactor cores
3. **Paths are independent**: Different signals can take overlapping paths - they're in superposition

### The Question

Starting from START, activation signals propagate through the network in quantum superposition. **How many total distinct valid paths exist from START to all reactor cores combined?**

More precisely: For each reactor R, count all valid paths from START to R (where a valid path visits each node at most once). Then **sum** these counts across all reactors.

### Example

Using a simple network:
```
START-A:10
START-B:5
A-REACTOR_1:8
B-REACTOR_1:12
B-C:7
C-REACTOR_2:6
```

Paths to REACTOR_1:
1. START ‚Üí A ‚Üí REACTOR_1
2. START ‚Üí B ‚Üí REACTOR_1

Paths to REACTOR_2:
1. START ‚Üí B ‚Üí C ‚Üí REACTOR_2

Total paths: 2 + 1 = **3**

### Complex Example

```
START-A:1
START-B:1
A-B:1
A-C:1
B-C:1
C-REACTOR_1:1
```

Paths to REACTOR_1:
1. START ‚Üí A ‚Üí C ‚Üí REACTOR_1
2. START ‚Üí A ‚Üí B ‚Üí C ‚Üí REACTOR_1
3. START ‚Üí B ‚Üí C ‚Üí REACTOR_1
4. START ‚Üí B ‚Üí A ‚Üí C ‚Üí REACTOR_1

Total paths: **4**

Note that START ‚Üí A ‚Üí B ‚Üí A ‚Üí C ‚Üí REACTOR_1 is INVALID (visits A twice).

### The Real Challenge

With your actual input (`day25_input.txt`):
- Hundreds of interconnected chambers
- 5 reactor cores
- Highly connected graph with many cycles
- The answer will be in the **hundreds of trillions** or more!

### Key Insights

This is similar to Day 11 Part 2 where you counted 390 trillion paths! You'll need:

1. **Memoization**: Cache results for (current_node, visited_set) states
2. **Efficient state representation**: Use bitmasks or maps for visited tracking
3. **Cycle detection**: Track visited nodes in current path to prevent revisiting
4. **DFS with backtracking**: Explore all paths recursively

### Hints

- The graph structure creates exponential path explosion
- Without memoization, this is computationally intractable
- With proper memoization, should run in 1-10 minutes
- The answer will be a very large integer (> 1 trillion, possibly > 1 quadrillion)
- Use `int` type (Go's int is 64-bit, can hold up to ~9 quintillion)

### Algorithm Sketch

```
function countPaths(graph, current, target, visited, memo):
    if current == target:
        return 1

    if (current, visited) in memo:
        return memo[(current, visited)]

    visited.add(current)
    totalPaths = 0

    for neighbor in graph[current]:
        if neighbor not in visited:
            totalPaths += countPaths(graph, neighbor, target, visited, memo)

    visited.remove(current)
    memo[(current, visited)] = totalPaths
    return totalPaths
```

Then sum over all reactors:
```
total = 0
for reactor in reactors:
    total += countPaths(graph, START, reactor, empty_set, memo)
return total
```

**This is the final challenge.** May your quantum calculations be swift! üéÑ‚öõÔ∏è

---

### Expected Answer Range

Your answer should be a very large integer, likely in the range:
- Minimum: 1 trillion (1,000,000,000,000)
- Typical: 10-500 trillion
- Maximum: Several quadrillion

If you get a small number (< 1 billion), your algorithm isn't counting all paths correctly!
